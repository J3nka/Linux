#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Getopt::Long;
use Term::ANSIColor;

my %options;

Getopt::Long::GetOptions(
    "help"            => sub{help()},

    "commit"          => \$options{"commit"},
    "overwrite"       => \$options{"overwrite"},
    "removeduplicate" => \$options{removeduplicate},
    "dir=s"           => \$options{"dir"},
    "noprompt"        => \$options{"noprompt"},
    "list"            => \$options{"list"},
    "replace=s"       => \%{$options{"replace"}},
    "debug"           => \$options{debug},

    "addactor=s"      => \@{${options}{add}{actor}},
    "addsource=s"     => \@{${options}{add}{source}},
    "addstory=s"      => \@{${options}{add}{story}},

    "actorlast"       => \$options{add}{actorlast},
    "sourcelast"      => \$options{add}{sourcelast},
    "storylast"       => \$options{add}{storylast},

    "actorstatic"     => \$options{add}{actorstatic},
    "sourcestatic"    => \$options{add}{sourcestatic},
    "storystatic"     => \$options{add}{storystatic},

    "actor=s"         => \@{$options{"filter"}{"actor"}},
    "source=s"        => \@{$options{"filter"}{"source"}},
    "story=s"         => \@{$options{"filter"}{"story"}},
    "title=s"         => \@{$options{"filter"}{"title"}},
    "quality=s"       => \@{$options{"filter"}{"quality"}},
    "filetype=s"      => \@{$options{"filter"}{"filetype"}},
    "date=s"          => \@{$options{"filter"}{"date"}},
) or help();

sub help {
print "Usage: $0 <input folder 1> <input folder 2> <...> <options>
\@ means that you can specify the option multiple times
--help              Print this helptext

--commit            Move files and clean input directories
--overwrite         Move files even on duplicate
--removeduplicate   If a file already exists with new filename, delete instead of move(be careful)
--dir               Set a custom output directory(default is same as input)
--noprompt          Dont prompt for source names
--list              List files instead of renaming and moving. Works with filters
--replace           \@Replaces part of the title, ex: --replace \"test=hej\"
--debug             Enable debugging

--addactor          \@Add actor to files, will still add actors from filename
--addsource         \@Add source to files, will still add sources from filename
--addstory          \@Add story to files, will still add stories from filename

--actorlast         Add added actors last instead of first
--sourcelast        Add added sources last instead of first
--storylast         Add added stories last instead of first

--actorstatic       Replace all actors with the ones specified with addactor
--sourcetatic       Replace all sources with the ones specified with addsource
--storystatic       Replace all stories with the ones specified with addstory

Filters:
--actor             \@Filter by actor
--source            \@Filter by source
--story             \@Filter by story
--title             \@Filter by title
--quality           \@Filter by quality
--filetype          \@Filter by filetype
--date              \@Filter by date
";
exit;
}

help() if !@ARGV;
my @LIST;
foreach my $arg (@ARGV) {
    logger("Parsing input paths");

    my @filepaths;
    chomp(@filepaths = `find "$arg" -type f`);
    foreach my $path (@filepaths) {
        $path = {
            filepath => $path,
            inpath   => $arg,
            dir      => $options{"dir"} // $arg,
        };
    }
    push @LIST, @filepaths;
}
@LIST = sort { $a->{filepath} cmp $b->{filepath} } @LIST;

my %renamedata;
get_actors(@LIST);
build_renamehash($_) for @LIST;
@LIST = filter(@LIST);

if ($options{"list"}) {
    print $_->{filepath},"\n" for @LIST;
    exit;
}

build_movepath(@LIST);
move_clean(@LIST);

sub logger {
    my ($message,$color) = @_;
    return if !$options{debug};
    print
        colored("DEBUG => ".((caller(1))[3] // (caller(0))[3]).($message?" => ":""),"magenta"),
        colored($message // "", $color // "white"),
        "\n";
}

sub filter {
    logger("Filtering list");

    my @LIST = @_;
    foreach my $param (keys %{$options{"filter"}}) {
        if (scalar @{$options{"filter"}{$param}} > 0) {
            @LIST = grep {
                    if ($_->{$param}) {
                        my $regex = join("|",@{$options{"filter"}{$param}});
                        if (ref $_->{$param} eq "ARRAY") {
                            grep { /$regex/i } @{$_->{$param}};
                        }
                        else {
                            $_->{$param} =~ /$regex/i;
                        }
                    }
                } @LIST;
        }
    }
    return @LIST;
}

sub get_actors {
    logger("Collecting actors");

    my @LIST = @_;
    foreach my $file (@LIST) {
        my $filename = (split("/",$file->{"filepath"}))[-1];
        my @actors = sort ($filename =~ /\(([^()]+)\)/g);
        push @{$renamedata{"actors"}}, @actors;
    }

    @{$renamedata{"actors"}} = grep { scalar (split(" ",$_)) > 1 } @{$renamedata{"actors"}};
    @{$renamedata{"actors"}} = unique(sort @{$renamedata{"actors"}});
    $_ =~ s/([\w']+)/\u\L$1/g for @{$renamedata{"actors"}};
}

sub build_renamehash {
    my $file = shift;
    logger("Building filehash: ".$file->{filepath});

    my @filesplit = split("/",$file->{"filepath"});
    $file->{"newfile"} = $file->{"orgfile"} = pop @filesplit;
    $file->{"newfile"} =~ s/([\w']+)/\u\L$1/g;
    $file->{"newfile"} =~ s/\s+/ /g;
    $file->{"newfile"} =~ s/^\s+|\s+$//g;

    get_filetype($file);
    get_source($file);
    get_actor($file);
    get_story($file);
    get_quality($file);
    get_date($file);
    add_custom_data($file);
    build_newfile($file);
}

sub get_filetype {
    my $file = shift;
    logger("Parsing filetype");

    $file->{"newfile"} =~ s/(\.\w+$)/\L$1/g;
    if ($file->{"newfile"} =~ /\.(\w+)$/) {
        $file->{"filetype"} = $1;
        $file->{"newfile"} =~ s/\.\w+$//;
    }
    else {
        push @{$file->{"error"}}, "No filetype";
    }
}

sub get_source {
    my $file = shift;
    logger("Parsing source");

    push @{$file->{"source"}}, $file->{"orgfile"} =~ /\[([^\[\]]+)\]/g;
    foreach my $source (@{$file->{"source"}}) {
        my $orgsource = $source;
        if (my @match = grep { $_ =~ /^(?:$source)$/i } keys %{$renamedata{"sources"}}) {
            $source = $renamedata{"sources"}{$match[0]};
        }
        else {
            if (!$options{"noprompt"}) {
                print "Enter source [$source]: ";
                chomp ($source = <STDIN>);
            }
            $source = $orgsource if $source eq "";
            $renamedata{"sources"}{$orgsource} = $source;
        }
    }
    $file->{"newfile"} =~ s/\[[^\[\]]+\]//ig;
}

sub get_actor {
    my $file = shift;
    logger("Parsing actor");

    if ($renamedata{"actors"}) {
        foreach my $actor(@{$renamedata{"actors"}}) {
            if ($file->{"newfile"} =~ /(^| )\(?$actor\)?($| )/i) {
                $file->{"newfile"} =~ s/(^| )\(?$actor\)?($| )/$1($actor)$2/i;
            }
        }
    }
    push @{$file->{"actor"}}, sort ($file->{"newfile"} =~ /\(([^()]+)\)/g);
    $file->{"newfile"} =~ s/\(([^()]+)\)//g;
    my $actors = join("|",@{$file->{"actor"}});
    while ($actors ne "" && $file->{"newfile"} =~ /^\s*($actors)/) {
        $file->{"newfile"} =~ s/^\s*($actors)//;
    }
}

sub get_story {
    my $file = shift;
    logger("Parsing story");

    push @{$file->{"story"}}, $file->{"newfile"} =~ /\{([^{}]+)\}/g;
    $file->{"newfile"} =~ s/\{([^{}]+)\}//g;
}

sub get_quality {
    my $file = shift;
    logger("Parsing/Extracting quality");

    if ($file->{newfile} && $file->{"newfile"} =~ /(^| )(\d{3,4})p($| )/i) {
        $file->{Resolution} = $2;
    }
    elsif (!$file->{Duration} || !$file->{Resolution} || !$file->{Bitrate}) {
        my %attrs = (
            Resolution => "\\d{3,4}x(\\d{3,4})",
            Duration => "Duration: (\\d{2}:\\d{2}:\\d{2})",
            Bitrate => "bitrate: (\\d+)",
        );
        chomp(my @mediainfo = `ffmpeg -i "$file->{filepath}" 2>&1 | egrep "Duration|Video:"`);
        foreach my $attr (keys %attrs) {
            join(" ",@mediainfo) =~ /$attrs{$attr}/;
            $file->{$attr} = $1
                or
            push @{$file->{error}}, "Failed to extract ".$attr;
        }
    }
    $file->{"newfile"} =~ s/(^| )(\d{3,4})p($| )/$1$3/i if $file->{newfile};
}

sub get_date {
    my $file = shift;
    logger("Parsing date");

    if ($file->{"newfile"} =~ /(^| )(\d{4}\D\d{2}\D\d{2})($| )/) {
        $file->{"date"} = $2;
        $file->{"date"} =~ s/\D/ /g;
        $file->{"newfile"} =~ s/(^| )(\d{4}\D\d{2}\D\d{2})($| )/$1$3/;
    }
}

sub add_custom_data {
    my $file = shift;
    logger("Adding custom Actors, Sources and Stories");

    foreach my $attribute (("actor","source","story")) {
        if ($options{add}{"$attribute"."static"}) {
            @{$file->{$attribute}} = @{$options{add}{$attribute}};
        }
        elsif ($options{add}{"$attribute"."last"}) {
            push @{$file->{$attribute}}, @{$options{add}{$attribute}};
        }
        else {
            unshift @{$file->{$attribute}}, @{$options{add}{$attribute}};
        }
    }
}

sub build_newfile {
    my $file = shift;
    logger("Building new filename");

    $file->{"newfile"} =~ s/^\s+|\s+$//g;
    $file->{"newfile"} =~ s/\s{2,}/ /g;

    foreach my $regex (keys %{$options{replace}}) {
        $file->{"newfile"} =~ s/$regex/$options{replace}{$regex}/g;
    }

    $file->{"newfile"} =~ s/^\s+|\s+$//g;
    $file->{"newfile"} =~ s/\s{2,}/ /g;
    $file->{"newfile"} = undef if $file->{newfile} eq "";

    my @filename;
    (scalar @{$file->{"source"}} > 0) and push @filename, join("",map { "[$_]" } @{$file->{"source"}});
    (scalar @{$file->{"actor"}} > 0) and push @filename, join(" ",map { "($_)" } sort @{$file->{"actor"}});
    (scalar @{$file->{"story"}} > 0) and push @filename, join(" ",map { "{$_}" } @{$file->{"story"}});
    push @filename, $file->{"newfile"} // undef;
    push @filename, $file->{"date"} // undef;
    push @filename, $file->{Resolution}? $file->{Resolution}."p" : undef;
    $file->{"newfile"} = sprintf("%s.%s", join(" ", grep { defined $_ } @filename), $file->{"filetype"} // "");
}

sub build_movepath {
    my @LIST = @_;
    logger("Building new movepath");

    foreach my $file (@LIST) {
        my @movepath;
        push @movepath, $file->{"dir"};
        push @movepath, scalar @{$file->{"source"}} > 0? @{$file->{"source"}}:"Other";

        if (scalar @{$file->{"actor"}} > 0) {
            push @movepath, ("#Actors",join(" & ", @{$file->{"actor"}}));
        }

        push @movepath, @{$file->{"story"}};
        $file->{"dir"} = join("/",@movepath);
    }
}

sub move_clean {
    my @LIST = @_;
    logger("Starting file moving and cleanup");

    foreach my $file (grep {!$_->{"error"}} @LIST) {
        my $dir = $file->{dir};
        next if $file->{"filepath"} eq $dir."/".$file->{"newfile"};
        if (! -e $dir && $options{"commit"}) {
            system "mkdir -p -m 700 \"$dir\"";
        }
        if (($options{overwrite} && $options{commit}) || ! -f $dir."/".$file->{"newfile"}) {
            if ($options{"commit"}) {
                system sprintf("chmod 600 \"%s\"", $file->{filepath});
                system sprintf("mv \"%s\" \"%s\"", $file->{"filepath"}, $dir."/".$file->{"newfile"});
            }
            printf("Old: \"%s\"\n", $file->{"filepath"});
            printf("New: \"%s\"\n\n", $dir."/".$file->{"newfile"});
        }
        else {
            if ($options{removeduplicate} && $options{commit}) {
                system sprintf "unlink \"%s\"\n", $file->{filepath};
            }
            my $oldfile = { filepath => $dir."/".$file->{"newfile"} };
            get_quality($_) for ($oldfile,$file);
            push @{$file->{"error"}}, sprintf("Duplicate: %s\nResolution(old/new): %s\nBitrate(old/new): %s\nDuration(old/new): %s\n%s\n%s\n",
                ($options{overwrite}?"New will overwrite old":$options{removeduplicate}?"Will delete new":"No active solution"),
                ($oldfile->{Resolution} // "")."/".($file->{Resolution} // ""),
                ($oldfile->{Bitrate} // "")."/".($file->{Bitrate} // ""),
                ($oldfile->{Duration} // "")."/".($file->{Duration} // ""),
                "--overwrite        Move new and overwrite old",
                "--removeduplicate  Delete new",
            );
        }
    }
    foreach my $file (grep {$_->{"error"}} @LIST) {
        printf("Old: %s\nNew: \"%s\"\n%s\n",
            colored($file->{dir}."/".$file->{newfile}, ($options{overwrite}?"red":$options{removeduplicate}?"green":"white")),
            colored($file->{filepath}, ($options{overwrite}?"green":$options{removeduplicate}?"red":"white")),
            join("\n",@{$file->{"error"}})
        );
    }
    foreach (@ARGV) {
        system sprintf("find \"%s\" -empty -delete", $_) if $options{commit};
    }
    print $options{commit}? colored("Moved files and cleaned old folders\n","green"):colored("No changes made\n","yellow");
}

sub unique {
    my %seen;
    return grep !$seen{$_}++, @_;
}
