#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Getopt::Long;
use Term::ANSIColor;

my %options;

Getopt::Long::GetOptions(
    "help"            => \&help,

    "commit"          => \$options{commit},

    "overwrite"       => \$options{overwrite},
    "removeduplicate" => \$options{removeduplicate},
    "keepboth"        => \$options{keepboth},

    "dir=s"           => \$options{dir},
    "forcemediainfo"  => \$options{forcemediainfo},
    "noprompt"        => \$options{noprompt},
    "list"            => \$options{list},
    "dump"            => \$options{dump},
    "delete"          => \$options{delete},
    "cleantitle"      => \$options{cleantitle},
    "debug"           => \$options{debug},

    "replaceactor=s"  => \%{$options{custom}{replace}{actor}},
    "replacesource=s" => \%{$options{custom}{replace}{source}},
    "replacestory=s"  => \%{$options{custom}{replace}{story}},

    "deleteactor=s"  => \@{$options{custom}{delete}{actor}},
    "deletesource=s" => \@{$options{custom}{delete}{source}},
    "deletestory=s"  => \@{$options{custom}{delete}{story}},

    "addactor=s"      => \@{$options{custom}{add}{actor}},
    "addsource=s"     => \@{$options{custom}{add}{source}},
    "addstory=s"      => \@{$options{custom}{add}{story}},

    "actorlast"       => \$options{custom}{add}{actorlast},
    "sourcelast"      => \$options{custom}{add}{sourcelast},
    "storylast"       => \$options{custom}{add}{storylast},

    "actorstatic"     => \$options{custom}{add}{actorstatic},
    "sourcestatic"    => \$options{custom}{add}{sourcestatic},
    "storystatic"     => \$options{custom}{add}{storystatic},

    "actor=s"         => \@{$options{filter}{actor}},
    "source=s"        => \@{$options{filter}{source}},
    "story=s"         => \@{$options{filter}{story}},
    "title=s"         => \@{$options{filter}{title}},
    "resolution=s"    => \@{$options{filter}{Resolution}},
    "filetype=s"      => \@{$options{filter}{filetype}},
    "date=s"          => \@{$options{filter}{date}},
) or help();

sub help {
print "Usage: $0 <input folder 1> <input folder 2> <...> <options>
\@ means that you can specify the option multiple times. You can also separate values with \",\"
--help              Print this helptext

--commit            Move files and clean input directories

--overwrite         Move files even on duplicate
--removeduplicate   If a file already exists with new filename, delete instead of move(be careful)
--keepboth          Adds an incrementing number at end of file to keep both

--dir               Set a custom output directory(default is same as input)
--forcemediainfo    Force extraction of mediainfo even if resolution exists in filename
--noprompt          Dont prompt for source names
--list              List files instead of renaming and moving. Works with filters
--dump              Same as list but Dumper instead
--delete            Delete found files, works with filters
--cleantitle        Removes -|_|,|.|! from file title, works on mp4|wmv|avi|mpg|ts|flv|mkv|jpg|mov
--debug             Enable debugging

--addactor          \@Add actor to files, will still add actors from filename
--addsource         \@Add source to files, will still add sources from filename
--addstory          \@Add story to files, will still add stories from filename

--actorlast         Add added actors last instead of first
--sourcelast        Add added sources last instead of first
--storylast         Add added stories last instead of first

--actorstatic       Replace all actors with the ones specified with addactor
--sourcetatic       Replace all sources with the ones specified with addsource
--storystatic       Replace all stories with the ones specified with addstory

Filters:
--actor             \@Filter by actor
--source            \@Filter by source
--story             \@Filter by story
--title             \@Filter by title
--resolution        \@Filter by quality <=> works as well. ex: <1080 for resolutions under 1080p
--filetype          \@Filter by filetype
--date              \@Filter by date
";
exit;
}

help() if !@ARGV;
my @LIST;
foreach my $arg (@ARGV) {
    logger("Parsing input paths");

    my @filepaths;
    chomp(@filepaths = `find "$arg" -type f`);
    foreach my $file (@filepaths) {
        my @filesplit = split("/",$file);
        my $newfile = my $orgfile = pop @filesplit;
        $newfile =~ s/-|_|,|!|\?|\.(?!\w+$)/ /g if $options{cleantitle};
        $newfile =~ s/([\w']+)/\u\L$1/g;
        $newfile =~ s/\s+/ /g;
        $newfile =~ s/^\s+|\s+$//g;
        $file = {
            filepath => $file,
            inpath   => $arg,
            dir      => $options{dir} // $arg,
            newfile  => $newfile,
            orgfile  => $orgfile,
        };
    }
    push @LIST, @filepaths;
}
@LIST = sort { $a->{orgfile} cmp $b->{orgfile} } @LIST;

my %renamedata;
my $count=1;
$| ++;
get_actors(@LIST);
get_source($_) for @LIST;
build_renamehash($_) for @LIST;
@LIST = filter(@LIST);
custom_data($_) for @LIST;
build_newfile($_) for @LIST;
build_movepath(@LIST);

if ($options{list} || $options{dump}) {
    print $options{list}? $_->{filepath}."\n": Dumper $_ for @LIST;
    exit;
}

if ($options{delete}) {
    foreach my $file (@LIST) {
        if (!$options{commit}) {
            print colored("Would delete " . $file->{filepath} . "\n", "yellow");
            next;
        }
        print colored("Deleting " . $file->{filepath} . "\n", "red");
        unlink $file->{filepath};
    }
    system sprintf("find $_ -empty -delete") for @ARGV;
    exit;
}

move_clean(@LIST);

sub logger {
    my ($message,$color) = @_;
    return if !$options{debug};
    print
        colored("DEBUG => ".((caller(1))[3] // (caller(0))[3]).($message?" => ":""),"magenta"),
        colored($message // "", $color // "white"),
        "\n";
}

sub filter {
    logger("Filtering list");

    my @LIST = @_;
    foreach my $param (keys %{$options{filter}}) {
        if (scalar @{$options{filter}{$param}} > 0) {
            @LIST = grep {
                    if ($_->{$param}) {
                        @{$options{filter}{$param}} = split(",",join(",",@{$options{filter}{$param}}));
                        my $regex = join("|",@{$options{filter}{$param}});
                        if (ref $_->{$param} eq "ARRAY") {
                            grep { /$regex/i } @{$_->{$param}};
                        }
                        elsif ($param eq "Resolution" && $regex =~ /^(\d+)p?$/) {
                            $_->{$param} == $1;
                        }
                        elsif ($regex =~ /^<=(\d+)p?$/) {
                            $_->{$param} <= $1;
                        }
                        elsif ($regex =~ /^<(\d+)p?/) {
                            $_->{$param} < $1;
                        }
                        elsif ($regex =~ /^>=(\d+)p?$/) {
                            $_->{$param} >= $1;
                        }
                        elsif ($regex =~ /^>(\d+)p?$/) {
                            $_->{$param} > $1;
                        }
                        else {
                            $_->{$param} =~ /$regex/i;
                        }
                    }
                } @LIST;
        }
    }
    return @LIST;
}

sub get_actors {
    logger("Collecting actors");

    my @LIST = @_;
    foreach my $file (@LIST) {
        my $filename = (split("/",$file->{filepath}))[-1];
        my @actors = sort ($filename =~ /\(([^()]+)\)/g);
        push @{$renamedata{actors}}, @actors;
    }

    @{$renamedata{actors}} = grep { scalar (split(" ",$_)) > 1 } @{$renamedata{actors}};
    @{$renamedata{actors}} = unique(sort @{$renamedata{actors}});
    $_ =~ s/([\w']+)/\u\L$1/g for @{$renamedata{actors}};
}

sub build_renamehash {
    my $file = shift;
    logger("Building filehash: ".$file->{filepath});

    get_filetype($file);
    get_actor($file);
    get_story($file);
    get_quality($file);
    get_date($file);
    printf("%d/%d (%.2f%%)\r", $count, scalar @LIST, $count*100/scalar @LIST);
    $count++;
}

sub get_filetype {
    my $file = shift;
    logger("Parsing filetype");

    $file->{newfile} =~ s/(\.\w+$)/\L$1/g;
    if ($file->{newfile} =~ /\.(\w+)$/) {
        $file->{filetype} = $1;
        $file->{newfile} =~ s/\.\w+$//;
    }
    else {
        push @{$file->{error}}, "Filetype: No filetype found";
    }
}

sub get_source {
    my $file = shift;
    logger("Parsing source");

    push @{$file->{source}}, $file->{orgfile} =~ /\[([^\[\]]+)\]/g;
    foreach my $source (@{$file->{source}}) {
        my $orgsource = $source;
        if (my @match = grep { $_ =~ /^(?:$source)$/i } keys %{$renamedata{sources}}) {
            $source = $renamedata{sources}{$match[0]}{source};
        }
        else {
            if (!$options{noprompt}) {
                print "Enter source [$source]: ";
                chomp ($source = <STDIN>);
                $source = $orgsource if $source eq "";
            }
            $renamedata{sources}{$orgsource}{source} = $source;
        }
    }
    $file->{newfile} =~ s/\[[^\[\]]+\]//ig;
}

sub get_actor {
    my $file = shift;
    logger("Parsing actor");

    if ($renamedata{actors}) {
        foreach my $actor(@{$renamedata{actors}}) {
            if ($file->{newfile} =~ /(^| )$actor($| )/i) {
                $file->{newfile} =~ s/(^| )$actor($| )/$1($actor)$2/gi;
            }
        }
    }
    push @{$file->{actor}}, sort ($file->{newfile} =~ /\(([^()]+)\)/g);
    $file->{newfile} =~ s/\(([^()]+)\)//g;
}

sub get_story {
    my $file = shift;
    logger("Parsing story");

    push @{$file->{story}}, $file->{newfile} =~ /\{([^{}]+)\}/g;
    $file->{newfile} =~ s/\{([^{}]+)\}//g;
}

sub get_quality {
    my $file = shift;
    logger("Parsing/Extracting quality");

    if (!$file->{duplicate} && $file->{newfile} =~ /(\W|^)(\d{3,4})p(\W|$)/i && !$options{forcemediainfo}) {
        $file->{Resolution} = $2;
    }
    elsif (!$file->{Duration} || !$file->{Resolution} || !$file->{Bitrate}) {
        my %attrs = (
            Resolution => "\\d{3,4}x(\\d{3,4})",
            Duration => "Duration: (\\d{2}:\\d{2}:\\d{2})",
            Bitrate => "bitrate: (\\d+)",
        );
        chomp(my @mediainfo = `ffmpeg -i "$file->{filepath}" 2>&1 | egrep "Duration|Video:"`);
        foreach my $attr (keys %attrs) {
            join(" ",@mediainfo) =~ /$attrs{$attr}/;
            if ($1) {
                $file->{$attr} = $1;
                delete $file->{$attr} if $file->{$attr} !~ /^[0-9:?]+$/;
            }
            elsif ($file->{filetype} !~ /^(jpg|png|gif|jpeg)$/i) {
                push @{$file->{error}}, $attr.": Failed to extract";
            }
        }
    }
    if (!$file->{duplicate}) {
        $file->{newfile} =~ s/(\W|^)(\d{3,4})p(\W|$)/$1$3/gi;
    }
}

sub get_date {
    my $file = shift;
    logger("Parsing date");

    if ($file->{newfile} =~ /(^|\W)(\d{4}\D\d{2}\D\d{2})($|\W)/) {
        $file->{date} = $2;
        $file->{date} =~ s/\D/ /g;
        $file->{newfile} =~ s/(^|\W)(\d{4}\D\d{2}\D\d{2})($|\W)/$1$3/g;
    }
}

sub custom_data {
    my $file = shift;
    logger("Adding custom Actors, Sources and Stories");

    foreach my $attribute (("actor","source","story")) {
        foreach my $delete (@{$options{custom}{delete}{$attribute}}) {
            /^$delete$/i and undef $_ for @{$file->{$attribute}};
        }
        @{$file->{$attribute}} = grep {defined $_} @{$file->{$attribute}};
        foreach my $replacement (keys %{$options{custom}{replace}{$attribute}}) {
            s/^$replacement$/$options{custom}{replace}{$attribute}{$replacement}/i for @{$file->{$attribute}};
        }
        @{$options{custom}{add}{$attribute}} = split(",",join(",",@{$options{custom}{add}{$attribute}}));
        if ($options{custom}{add}{$attribute."static"}) {
            @{$file->{$attribute}} = @{$options{custom}{add}{$attribute}};
        }
        elsif ($options{custom}{add}{$attribute."last"}) {
            push @{$file->{$attribute}}, @{$options{custom}{add}{$attribute}};
        }
        else {
            unshift @{$file->{$attribute}}, @{$options{custom}{add}{$attribute}};
        }
        @{$file->{$attribute}} = unique(@{$file->{$attribute}});
        s/^\s+|\s+$//g for @{$file->{$attribute}};
    }
}

sub build_newfile {
    my $file = shift;
    logger("Building new filename");

    $file->{newfile} =~ s/^\s+|\s+$//g;
    $file->{newfile} =~ s/\s{2,}/ /g;
    $file->{newfile} = undef if $file->{newfile} eq "";
    $file->{title} = $file->{newfile} if !$file->{duplicate};

    my @filename;
    (scalar @{$file->{source}} > 0) and push @filename, join("",map { "[$_]" } @{$file->{source}});
    (scalar @{$file->{actor}} > 0) and push @filename, join(" ",map { "($_)" } sort @{$file->{actor}});
    (scalar @{$file->{story}} > 0) and push @filename, join(" ",map { "{$_}" } @{$file->{story}});
    push @filename, $file->{title} // undef;
    if ($file->{duplicate}) {
        push @filename, $file->{duplicate};
        $file->{duplicate}++;
    }
    push @filename, $file->{date} // undef;
    push @filename, $file->{Resolution}? $file->{Resolution}."p" : undef;
    $file->{newfile} = sprintf("%s.%s", join(" ", grep { defined $_ } @filename), $file->{filetype} // "");
}

sub build_movepath {
    my @LIST = @_;
    logger("Building new movepath");

    foreach my $file (@LIST) {
        my @movepath;
        push @movepath, $file->{dir};
        push @movepath, scalar @{$file->{source}} > 0? @{$file->{source}}:"Other";

        if (scalar @{$file->{actor}} > 0) {
            push @movepath, ("#Actors",join(" & ", @{$file->{actor}}));
        }

        push @movepath, @{$file->{story}};
        $file->{dir} = join("/",@movepath);
    }
}

sub move_clean {
    my @LIST = @_;
    logger("Starting file moving and cleanup");

    foreach my $file (grep {!$_->{error}} @LIST) {
        my $dir = $file->{dir};
        next if $file->{filepath} eq $dir."/".$file->{newfile};
        if ($options{keepboth}) {
            $file->{duplicate} = 1;
            build_newfile($file) until ! -f $dir."/".$file->{newfile} && !grep {$_->{dir} ne $file->{dir} && $_->{newfile} ne $file->{newfile}} @LIST;
        }
        if (($options{overwrite} && $options{commit}) || ! -f $dir."/".$file->{newfile}) {
            if ($options{commit}) {
                system "mkdir -p -m 700 \"$dir\"" if ! -e $dir;
                system sprintf("chmod 600 \"%s\"", $file->{filepath});
                system sprintf("mv \"%s\" \"%s\"", $file->{filepath}, $dir."/".$file->{newfile});
            }
            printf("Input:  \"%s\"\n", $file->{filepath});
            printf("Output: \"%s\"\n\n", $dir."/".$file->{newfile});
        }
        else {
            if ($options{removeduplicate} && $options{commit}) {
                system sprintf "rm \"%s\"\n", $file->{filepath};
                printf("Existing:\"%s\"\n", colored($dir."/".$file->{newfile},"green"));
                printf("New:     \"%s\"\n\n", colored($file->{filepath}, "red"));
                next;
            }
            my $oldfile = {
                filepath  => $dir."/".$file->{newfile},
                duplicate => 1,
                newfile   => $file->{newfile},
            };
            $file->{duplicate} = 1;
            get_quality($_) for ($oldfile,$file);
            push @{$file->{error}}, sprintf("Duplicate: %s", $options{overwrite}?"New will overwrite existing":$options{removeduplicate}?"Will delete new":"No active solution");
            foreach ("Resolution","Bitrate","Duration") {
                push @{$file->{error}}, sprintf("%-10s(existing/new): %s/%s",$_,$oldfile->{$_} // "",$file->{$_} // "");
            }
            push @{$file->{error}}, "--overwrite        Move new and overwrite existing";
            push @{$file->{error}}, "--removeduplicate  Delete new";
            push @{$file->{error}}, "--keepboth         Add Dup X to end of newfile";
        }
    }
    foreach my $file (grep {$_->{error} && $_->{duplicate}} @LIST) {
            printf("Existing: \"%s\"\n",colored($file->{dir}."/".$file->{newfile}, ($options{overwrite}?"red":$options{removeduplicate}?"green":"reset")));
            printf("New:      \"%s\"\n",colored($file->{filepath}, ($options{overwrite}?"green":$options{removeduplicate}?"red":"reset")));
            printf("%s\n", colored("Errors:", "magenta"));
            print join("\n",@{$file->{"error"}})."\n\n";
    }
    foreach my $file (grep {$_->{error} && !$_->{duplicate}} @LIST) {
        printf("Input:  \"%s\"\nOutput: \"%s\"\n%s\n%s\n\n",
            $file->{filepath},
            $file->{dir}."/".$file->{newfile},
            colored("Errors:", "magenta"),
            join("\n",@{$file->{"error"}})
        );
    }
    $options{commit} and -e "$_" and system sprintf("find \"%s\" -empty -delete", $_) for @ARGV;
    print $options{commit}? colored("Moved files and cleaned old folders\n","green"):colored("No changes made\n","yellow");
}

sub unique {
    my %seen;
    return grep !$seen{$_}++, @_;
}
