#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Getopt::Long;
use Term::ANSIColor;
use Mediainfo;

my %options;
my %filetree;
my $currentyear = `date "+%Y"`;
my @LIST;
my %renamedata;
my $count = 1;
$|++;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

Getopt::Long::GetOptions(
    "help"            => \&help,

    "commit"          => \$options{commit},

    "list"            => \$options{list},
    "dump"            => \$options{dump},
    "delete"          => \$options{delete},

    "dir=s"           => \$options{dir},
    "forcemediainfo"  => \$options{forcemediainfo},
    "noprompt"        => \$options{noprompt},
    "cleantitle"      => \$options{cleantitle},
    "debug"           => \$options{debug},

    "overwrite"       => \$options{overwrite},
    "removeduplicate" => \$options{removeduplicate},
    "keepboth"        => \$options{keepboth},

    "replaceactor=s"  => \%{$options{custom}{replace}{actor}},
    "replacesource=s" => \%{$options{custom}{replace}{source}},
    "replacestory=s"  => \%{$options{custom}{replace}{story}},

    "deleteactor=s"   => \@{$options{custom}{delete}{actor}},
    "deletesource=s"  => \@{$options{custom}{delete}{source}},
    "deletestory=s"   => \@{$options{custom}{delete}{story}},

    "addactor=s"      => \@{$options{custom}{add}{actor}},
    "addsource=s"     => \@{$options{custom}{add}{source}},
    "addstory=s"      => \@{$options{custom}{add}{story}},

    "lastactor"       => \$options{custom}{add}{lastactor},
    "lastsource"      => \$options{custom}{add}{lastsource},
    "laststory"       => \$options{custom}{add}{laststroy},

    "staticactor"     => \$options{custom}{add}{staticactor},
    "staticsource"    => \$options{custom}{add}{staticsource},
    "staticstory"     => \$options{custom}{add}{staticstory},

    "actor=s"         => \@{$options{filter}{actor}},
    "source=s"        => \@{$options{filter}{source}},
    "story=s"         => \@{$options{filter}{story}},
    "title=s"         => \@{$options{filter}{title}},
    "resolution=s"    => \@{$options{filter}{Resolution}},
    "filetype=s"      => \@{$options{filter}{filetype}},
    "date=s"          => \@{$options{filter}{date}},
) or help();

sub help {
print "Usage: $0 <input folder 1> <input folder 2> <...> <options>
    --help              Print this helptext

    --commit            Move files and clean input directories

    --list              List files instead of renaming and moving. Works with filters
    --dump              Same as list but Dumper instead
    --delete            Delete found files, works with filters

    --dir               Set a custom output directory(default is same as input)
    --forcemediainfo    Force extraction of mediainfo even if resolution exists in filename
    --noprompt          Dont prompt for source names
    --cleantitle        Removes -|_|,|.|! from file title
    --debug             Enable debugging

    --overwrite         Move files even on duplicate
    --removeduplicate   If a file already exists with new filename, delete instead of move(be careful)
    --keepboth          Adds an incrementing number at end of file to keep both

Data manipulation on attributes actor, source and story.
Available methods are \"replace,delete,add,last,static\"
Use like \"--methodattribute\" ex: \"--addactor nameofactor\"
\@ means that you can specify the option multiple times. You can also separate values with \",\"
\% means that the option requires a key and a value like \"key=value\"

    replace             \%Replace attribute \"oldattribute=newattribute\"
    delete              \@Delete attribute from file
    add                 \@Add attribute to files, will still add attributes from filename
    last                Add added attributes last instead of first
    static              Replace all attributes with the ones specified with addmethod

Filters:
    --actor             \@Filter by actor
    --source            \@Filter by source
    --story             \@Filter by story
    --title             \@Filter by title
    --resolution        \@Filter by quality <=> works as well. ex: <1080 for resolutions under 1080p
    --filetype          \@Filter by filetype
    --date              \@Filter by date
";
exit;
}

@LIST = find_files(@ARGV);

build_renamehash(@LIST);
get_actors(@LIST);

@LIST = filter(@LIST);

do { custom_data($_); build_newfile($_); build_movepath($_) } for @LIST;

if ($options{list} || $options{dump} || $options{delete}) {
    foreach my $file (@LIST) {
        if ($options{list}) {
            my $temptree = \%filetree;
            my @movepath = split("/",$file->{filepath});
            pop @movepath;
            while (my $folder = shift @movepath) {
                if (scalar @movepath == 0) {
                    $temptree->{$folder}{$file->{orgfile}} = 1;
                }
                else {
                    $temptree->{$folder} ||= {};
                    $temptree = $temptree->{$folder}
                }
            }
        }
        elsif ($options{delete}) {
            if (!$options{commit}) {
                print colored("Would delete " . $file->{filepath} . "\n", "yellow");
                next;
            }
            print colored("Deleting " . $file->{filepath} . "\n", "red");
            unlink $file->{filepath};
        }
    }
    if ($options{list}) {
        print Dumper \%filetree;
    }
    elsif ($options{dump}) {
        print Dumper \@LIST;
    }
    elsif($options{delete} && $options{commit}) {
        system sprintf("find $_ -empty -delete") for @ARGV;
    }
    exit;
}

move_clean(@LIST);

sub find_files {
    logger("Finding files in input paths");

    my @args = @_ or help();
    my @LIST;

    foreach my $arg (@args) {
        chomp(my @filepaths = `find "$arg" -type f`);
        foreach my $file (@filepaths) {
            my @filesplit = split("/",$file);
            my $newfile = my $orgfile = pop @filesplit;
            $newfile =~ s/´|`|’/'/g;
            $newfile =~ s/-|_|,|!|\?|\.(?!\w+$)/ /g if $options{cleantitle};
            $newfile =~ s/([\w']+)/\u\L$1/g;
            $newfile =~ s/\s+/ /g;
            $newfile =~ s/^\s+|\s+$//g;
            $file = {
                filepath => $file,
                inpath   => $arg,
                dir      => $options{dir} // $arg,
                newfile  => $newfile,
                orgfile  => $orgfile,
            };
            my @left_parenths = $file->{newfile} =~ /(\(|\{|\[)/g;
            my @right_parenths = $file->{newfile} =~ /(\)|\}|\])/g;
            if (@left_parenths != @right_parenths) {
                push @{$file->{error}}, "Uneven number of parethesis, brackets, or curly brackets";
                next;
            }
        }
        push @LIST, @filepaths;
    }

    @LIST = sort { $a->{orgfile} cmp $b->{orgfile} } @LIST;

    return @LIST;
}

sub logger {
    my ($message,$color) = @_;
    return if !$options{debug};
    print
        colored("DEBUG => ".((caller(1))[3] // (caller(0))[3]).($message?" => ":""),"magenta"),
        colored($message // "", $color // "white"),
        "\n";
}

sub filter {
    logger("Filtering list");

    my @LIST = @_;
    foreach my $param (keys %{$options{filter}}) {
        if (scalar @{$options{filter}{$param}} > 0) {
            @LIST =
                grep {
                    if ($_->{$param}) {
                        @{$options{filter}{$param}} = split(",",join(",",@{$options{filter}{$param}}));
                        my $regex = join("|",@{$options{filter}{$param}});
                        if (ref $_->{$param} eq "ARRAY") {
                            grep { /$regex/i } @{$_->{$param}};
                        }
                        elsif ($param eq "Resolution" && $regex =~ /^(\d+)p?$/) {
                            $_->{$param} == $1;
                        }
                        elsif ($regex =~ /^([<=>]+)(\d+)p?$/) {
                            eval "$_->{$param} $1 $2";
                        }
                        else {
                            $_->{$param} =~ /$regex/i;
                        }
                    }
                } @LIST;
        }
    }
    return @LIST;
}

sub get_actors {
    logger("Collecting actors");
    my @LIST = @_;

    foreach my $file (@LIST) {
        my @actors = $file->{newfile} =~ /\(([^()]+)\)/g;
        $renamedata{actors}{$_} = 1 for grep { scalar (split(" ",$_)) > 1 } @actors;
        push @{$file->{actor}}, @actors;
        $file->{newfile} =~ s/(\W|^)$_(\W|$)/$1$2/ig for @actors;;
    }

    foreach my $n (0..$#LIST) {
        my $file = $LIST[$n];
        foreach my $actor (keys %{$renamedata{actors}}, @{$file->{actor}} ) {
            next unless $file->{newfile} =~ /(\W|^)$actor(\W|$)/i;
            push @{$file->{actor}}, $actor unless grep { $_ eq $actor } @{$file->{actor}};
            $file->{newfile} =~ s/(\W|^)$actor(\W|$)/$1$2/ig;
        }
        $file->{newfile} =~ s/\(|\)//g;
        printf("%-25s => %d/%d (%.2f%%)\r", (caller(0))[3], $n+1, scalar @LIST, ($n+1)*100/scalar @LIST);
    }
    print "\n";
}

sub build_renamehash {
    logger("Building filehash");
    my @LIST = @_;

    foreach my $n (0..$#LIST) {
        my $file = $LIST[$n];

        next unless get_source($file);
        next unless get_filetype($file);
        next unless get_story($file);
        next unless get_quality($file);
        next unless get_date($file);

        printf("%-25s => %d/%d (%.2f%%)\r", (caller(0))[3], $n+1, scalar @LIST, ($n+1)*100/scalar @LIST);
    }
    print "\n";
}

sub get_filetype {
    logger("Parsing filetype");
    my $file = shift;

    if (($file->{filetype}) = (lc $file->{newfile}) =~ /\.(\w+)$/) {
        $file->{newfile} =~ s/\.\w+$//;
    }
    else {
        push @{$file->{error}}, "Filetype: No filetype found";
    }
}

sub get_source {
    logger("Parsing source");
    my $file = shift;

    push @{$file->{source}}, $file->{orgfile} =~ /\[([^\[\]]+)\]/g;
    foreach my $source (@{$file->{source}}) {
        my $orgsource = $source;
        if ($renamedata{sources}{lc $source}) {
            $source = $renamedata{sources}{lc $source};
        }
        else {
            if (!$options{noprompt}) {
                print "Enter source [$source]: ";
                chomp ($source = <STDIN>);
                $source = $orgsource if $source eq "";
            }
            $renamedata{sources}{lc $orgsource} = $source;
        }
    }
    $file->{newfile} =~ s/\[[^\[\]]+\]//ig;

    return 1;
}

sub get_story {
    logger("Parsing story");
    my $file = shift;

    push @{$file->{story}}, $file->{newfile} =~ /\{([^{}]+)\}/g;
    $file->{newfile} =~ s/\{([^{}]+)\}//g;

    return 1;
}

sub get_quality {
    my $file = shift;
    logger("Parsing/Extracting quality");

    if (!$file->{filetype}) {
        ($file->{filetype}) = $file->{filepath} =~ /\.(\w+)$/;
        return unless $file->{filetype};
    }

    if (!$file->{duplicate} && !$options{forcemediainfo} && $file->{newfile} =~ /(\W|^)(\d{3,4})p(\W|$)/i) {
        $file->{Resolution} = $2;
    }
    elsif (!$file->{Duration} || !$file->{Resolution} || !$file->{Bitrate}) {
        my $mediainfo;
        eval { $mediainfo  = Mediainfo->new(filename => $file->{filepath}) };
        $file->{Resolution} = $mediainfo->{height};
        if ($mediainfo->{video_length} && $mediainfo->{video_bitrate}) {
            $file->{Bitrate}    = sprintf("%.2f Mbit/s", $mediainfo->{video_bitrate} / 1000000);
            $file->{Duration}   = sprintf("%dm %ds", $mediainfo->{video_length} / 60000, $mediainfo->{video_length} / 1000 % 60);
        }
    }
    if (!$file->{duplicate}) {
        $file->{newfile} =~ s/(\W|^)(\d{3,4})p(\W|$)/$1$3/gi;
    }

    return 1;
}

sub get_date {
    logger("Parsing date");
    my $file = shift;

    if ($file->{newfile} =~ /(^|\W)(\d{4}|\d{2})\D(\d{2})\D(\d{2})($|\W)/) {
        my ($year, $month, $day) = ($2,$3,$4);
        if (length $year == 2) {
            $year = "20".$year;
        }
        if (($year > $currentyear) || ($month < 01 || $month > 12) || ($day < 01 || $day > 31)) {
            return;
        }
        $file->{date} = "$year $month $day";
        $file->{newfile} =~ s/(^|\W)((?:\d{4}|\d{2})\D\d{2}\D\d{2})($|\W)/$1$3/g;
    }

    return 1;
}

sub custom_data {
    logger("Adding custom Actors, Sources and Stories");
    my $file = shift;

    foreach my $attribute (("actor","source","story")) {
        s/^\s+|\s+$//g for @{$file->{$attribute}};
        foreach my $delete (@{$options{custom}{delete}{$attribute}}) {
            /^$delete$/i and undef $_ for @{$file->{$attribute}};
        }
        @{$file->{$attribute}} = grep {defined $_} @{$file->{$attribute}};

        foreach my $replacement (keys %{$options{custom}{replace}{$attribute}}) {
            s/^$replacement$/$options{custom}{replace}{$attribute}{$replacement}/i for @{$file->{$attribute}};
        }

        @{$options{custom}{add}{$attribute}} = split(",",join(",",@{$options{custom}{add}{$attribute}}));

        if ($options{custom}{add}{"static".$attribute}) {
            @{$file->{$attribute}} = @{$options{custom}{add}{$attribute}};
        }
        elsif ($options{custom}{add}{"last".$attribute}) {
            push @{$file->{$attribute}}, @{$options{custom}{add}{$attribute}};
        }
        else {
            unshift @{$file->{$attribute}}, @{$options{custom}{add}{$attribute}};
        }

        @{$file->{$attribute}} = unique(@{$file->{$attribute}});
        s/^\s+|\s+$//g for @{$file->{$attribute}};
    }

    return 1;
}

sub build_newfile {
    logger("Building new filename");
    my $file = shift;

    $file->{newfile} =~ s/^\s+|\s+$//g;
    $file->{newfile} =~ s/\s{2,}/ /g;
    $file->{newfile} = undef if $file->{newfile} eq "";
    $file->{title} = $file->{newfile} if !$file->{duplicate};

    my @filename;
    push @filename, join("",map { "[$_]" } @{$file->{source}}) if scalar @{$file->{source}};
    push @filename, join(" ",map { "($_)" } sort @{$file->{actor}}) if scalar @{$file->{actor}};
    push @filename, join(" ",map { "{$_}" } @{$file->{story}}) if scalar @{$file->{story}};
    push @filename, $file->{title} // ();
    if ($file->{duplicate}) {
        push @filename, $file->{duplicate};
        $file->{duplicate}++;
    }
    push @filename, $file->{date} // ();
    push @filename, $file->{Resolution}? $file->{Resolution}."p" : ();
    $file->{newfile} = sprintf("%s.%s", join(" ", @filename), $file->{filetype} // "");

    return 1;
}

sub build_movepath {
    logger("Building new movepath");
    my $file = shift;

    my @movepath;
    push @movepath, $file->{dir};
    push @movepath, scalar @{$file->{source}}? @{$file->{source}} : "Other";
    push @movepath, ("#Actors",join(" & ", sort @{$file->{actor}})) if scalar @{$file->{actor}};
    push @movepath, @{$file->{story}};
    $file->{dir} = join("/",@movepath);

    return 1;
}

sub move_clean {
    logger("Starting file moving and cleanup");
    my @LIST = @_;

    foreach my $file (grep {!$_->{error}} @LIST) {
        my $dir = $file->{dir};
        next if $file->{filepath} eq $dir."/".$file->{newfile};
        if ($options{keepboth}) {
            $file->{duplicate} = 1;
            build_newfile($file) until ! -f $dir."/".$file->{newfile};
        }
        if (($options{overwrite} && $options{commit}) || ! -f $dir."/".$file->{newfile}) {
            if ($options{commit}) {
                system "mkdir -p -m 700 \"$dir\"" if ! -e $dir;
                system sprintf("chmod 600 \"%s\"", $file->{filepath});
                system sprintf("mv \"%s\" \"%s\"", $file->{filepath}, $dir."/".$file->{newfile});
            }
            printf("Input:  \"%s\"\n", $file->{filepath});
            printf("Output: \"%s\"\n\n", $dir."/".$file->{newfile});
        }
        else {
            if ($options{removeduplicate} && $options{commit}) {
                system sprintf "rm \"%s\"\n", $file->{filepath};
                printf("Existing:\"%s\"\n", colored($dir."/".$file->{newfile},"green"));
                printf("New:     \"%s\"\n\n", colored($file->{filepath}, "red"));
                next;
            }
            my $oldfile = {
                filepath  => $dir."/".$file->{newfile},
                duplicate => 1,
                newfile   => $file->{newfile},
            };
            $file->{duplicate} = 1;
            next unless get_quality($oldfile);
            next unless get_quality($file);
            push @{$file->{error}}, sprintf("Duplicate: %s", $options{overwrite}?"New will overwrite existing":$options{removeduplicate}?"Will delete new":"No active solution");
            foreach ("Resolution","Bitrate","Duration") {
                push @{$file->{error}}, sprintf("%-10s(existing/new): %s/%s",$_,$oldfile->{$_} // "",$file->{$_} // "");
            }
            push @{$file->{error}}, "--overwrite        Move new and overwrite existing";
            push @{$file->{error}}, "--removeduplicate  Delete new";
            push @{$file->{error}}, "--keepboth         Add X to end of newfile";
        }
    }
    foreach my $file (grep {$_->{error} && $_->{duplicate}} @LIST) {
            printf("Existing: \"%s\"\n",colored($file->{dir}."/".$file->{newfile}, ($options{overwrite}?"red":$options{removeduplicate}?"green":"reset")));
            printf("New:      \"%s\"\n",colored($file->{filepath}, ($options{overwrite}?"green":$options{removeduplicate}?"red":"reset")));
            printf("%s\n", colored("Errors:", "magenta"));
            print join("\n",@{$file->{"error"}})."\n\n";
    }
    foreach my $file (grep {$_->{error} && !$_->{duplicate}} @LIST) {
        printf("Input:  \"%s\"\nOutput: \"%s\"\n%s\n%s\n\n",
            $file->{filepath},
            $file->{dir}."/".$file->{newfile},
            colored("Errors:", "magenta"),
            join("\n",@{$file->{"error"}})
        );
    }
    $options{commit} and -e "$_" and system sprintf("find \"%s\" -empty -delete", $_) for @ARGV;
    print $options{commit}? colored("Moved files and cleaned old folders\n","green"):colored("No changes made               \n","yellow");

    return 1;
}

sub unique {
    my %seen;
    return grep !$seen{$_}++, @_;
}
