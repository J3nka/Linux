#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Getopt::Long;

my %options;

Getopt::Long::GetOptions(
    "commit"     => \$options{"commit"},
    "force"      => \$options{"force"},
    "actor=s"    => \$options{"filter"}{"actors"},
    "title=s"    => \$options{"filter"}{"title"},
    "quality=s"  => \$options{"filter"}{"title"},
    "story=s"    => \$options{"filter"}{"story"},
    "filetype=s" => \$options{"filter"}{"filetype"},
    "source=s"   => \$options{"filter"}{"source"},
    "date=s"     => \$options{"filter"}{"date"},
    "renameonpath" => \$options{"renameonpath"},
    "duplicates" => \$options{"duplicates"},
);

exit print "Missing input directory\n" if !$ARGV[0];
my @LIST;
if ($options{"renameonpath"} && $options{"filter"}{"source"}) {
    chomp(@LIST=`find "$ARGV[0]/$options{'filter'}{'source'}" -type f`);
}
else {
    chomp(@LIST=`find "$ARGV[0]" -type f`);
}
my %renamedata;
my $out = $ARGV[1]||$ARGV[0];
@LIST = map { { "filepath" => $_ } } sort @LIST;

get_actors(@LIST);
build_renamehash(@LIST);
@LIST = filter(@LIST);
if ($options{"duplicates"}) {
    @LIST = video_info(@LIST);
    my $count = find_duplicates(@LIST);
    foreach my $attribute(keys %$count) {
        foreach my $duplicate ( grep {scalar @{$count->{$attribute}->{$_}} < 2 } keys %{$count->{$attribute}}) {
            delete $count->{$attribute}->{$duplicate};
        }
    }
    print Dumper $count;
    exit;
}
build_movepath(@LIST);
move_clean(@LIST);

sub filter {
    my @LIST = @_;
    foreach my $param (keys %{$options{"filter"}}) {
        if ($options{"filter"}{$param}) {
            @LIST = grep {
                    if ($_->{$param}) {
                        if (ref $_->{$param} eq "ARRAY") {
                            grep { /$options{"filter"}{$param}/i } @{$_->{$param}};
                        }
                        else {
                            $_->{$param} =~ /$options{"filter"}{$param}/i
                        }
                    }
                } @LIST;
        }
    }
    return @LIST;
}

sub get_actors {
    my @LIST = @_;
    foreach my $file (@LIST) {
        my $filename = (split("/",$file->{"filepath"}))[-1];
        my @actors = sort ($filename =~ /\(([^()]+)\)/g);
        push @{$renamedata{"actors"}}, @actors;
    }

    @{$renamedata{"actors"}} = grep { scalar (split(" ",$_)) > 1 } @{$renamedata{"actors"}};
    @{$renamedata{"actors"}} = unique(sort @{$renamedata{"actors"}});
}

sub build_renamehash {
    my @LIST = @_;
    foreach my $file (@LIST) {
        my @filesplit = split("/",$file->{"filepath"});
        $file->{"newfile"} = $file->{"orgfile"} = pop @filesplit;
        $file->{"newfile"} =~ s/([\w']+)/\u\L$1/g;
        $file->{"newfile"} =~ s/(\.\w+$)/\L$1/g;
        $file->{"inpath"} = join("/",@filesplit);
        if ($file->{"newfile"} =~ /\.(\w+)$/) {
            $file->{"filetype"} = $1;
            $file->{"newfile"} =~ s/\.\w+$//;
        }
        else {
            print "No filetype for ".$file->{"filepath"}."\n";
            undef $file;
            next;
        }
        @{$file->{"source"}} = $file->{"orgfile"} =~ /\[([^\[\]]+)\]/g;
        foreach my $source (@{$file->{"source"}}) {
            next if $options{"renameonpath"};
            my $orgsource = $source;
            if (my @match = grep { $_ =~ /^(?:$source)$/i } keys %{$renamedata{"sources"}}) {
                $source = $renamedata{"sources"}{$match[0]};
            }
            else {
                if (!$options{"force"}) {
                    print "Enter source [$source]: ";
                    chomp ($source = <STDIN>);
                }
                $source = $orgsource if $source eq "";
                $renamedata{"sources"}{$orgsource} = $source;
            }
        }
        $file->{"newfile"} =~ s/\[[^\[\]]+\]//ig;
        if ($renamedata{"actors"}) {
            foreach my $actor(@{$renamedata{"actors"}}) {
                if ($file->{"newfile"} =~ /(^| )\(?$actor\)?($| )/i) {
                    $file->{"newfile"} =~ s/(^| )\(?$actor\)?($| )/$1($actor)$2/i;
                }
            }
        }
        @{$file->{"actors"}} = sort ($file->{"newfile"} =~ /\(([^()]+)\)/g);
        $file->{"newfile"} =~ s/\(([^()]+)\)//g;
        @{$file->{"story"}} = $file->{"newfile"} =~ /\{([^{}]+)\}/g;
        $file->{"newfile"} =~ s/\{([^{}]+)\}//g;
        if ($file->{"newfile"} =~ /(^| )(\d{3,4})p($| )/i) {
            $file->{"quality"} = $2;
            $file->{"newfile"} =~ s/(^| )(\d{3,4})p($| )/$1$3/i;
        }
        else {
            chomp(my @videoinfo = `ffmpeg -i "$file->{filepath}" 2>&1 | egrep "Video:"`);
            if ($videoinfo[0]) {
                @videoinfo = grep {/\d{3,4}x\d{3,4}/} split(",",$videoinfo[0]);
                my $resolution = (split("x",$videoinfo[0]))[1] // undef;
                $file->{"quality"} = (split(" ",$resolution))[0] // undef;
            }
            else {
                printf ("Error [Resolution]: %s", $file->{"filepath"});
            }
        }
        if ($file->{"newfile"} =~ /(^| )(\d{4}\D\d{2}\D\d{2})($| )/) {
            $file->{"date"} = $2;
            $file->{"date"} =~ s/\D/ /g;
            $file->{"newfile"} =~ s/(^| )(\d{4}\D\d{2}\D\d{2})($| )/$1$3/;
        }
        $file->{"newfile"} =~ s/\s+/ /g;
        $file->{"newfile"} =~ s/^\s+|\s+$//g;
        $file->{"title"} = $file->{"newfile"};
        $file->{"newfile"} = "";
        if ($options{"renameonpath"}) {
            @{$file->{"actors"}} = ();
            @{$file->{"source"}} = ();
            @{$file->{"story"}} = ();
            my ($relativepath) = $file->{"filepath"} =~ /$ARGV[0]\/?(.*)/;
            my @path = split("/",$relativepath);
            pop @path;
            while ($path[0] and $path[0] !~ /^(#Actors|Other)$/) {
                push @{$file->{"source"}}, shift @path;
            }
            while (my $folder = shift @path) {
                if ($folder eq "#Actors") {
                    @{$file->{"actors"}} = split(" & ", shift @path);
                    next;
                }
                next if $folder eq "Other";
                push @{$file->{"story"}}, $folder;
            }
        }
        my @filename;
        (scalar @{$file->{"source"}} > 0) and push @filename, join(" ",map { "[$_]" } @{$file->{"source"}});
        (scalar @{$file->{"actors"}} > 0) and push @filename, join(" ",map { "($_)" } sort @{$file->{"actors"}});
        (scalar @{$file->{"story"}} > 0) and push @filename, join(" ",map { "{$_}" } @{$file->{"story"}});
        $file->{"title"} and push @filename, $file->{"title"};
        $file->{"date"} and push @filename, $file->{"date"};
        $file->{"quality"} and push @filename, $file->{"quality"}."p";
        $file->{"newfile"} = join(" ", @filename).".".$file->{"filetype"}
    }
}

sub build_movepath {
    my @LIST = @_;
    foreach my $file (@LIST) {
        my @movepaths;
        my @movepath;
        push @movepath, $out;
        push @movepath, scalar @{$file->{"source"}} > 0? @{$file->{"source"}}:"Other";
        if (scalar @{$file->{"actors"}} > 0) {
            push @movepath, ("#Actors",join(" & ", @{$file->{"actors"}}));
        }
        push @movepath, @{$file->{"story"}};
        push @movepaths, join("/",@movepath);
        @{$file->{"outpaths"}} = @movepaths;
    }
}

sub move_clean {
    my @LIST = @_;
    foreach my $file (@LIST) {
        foreach my $outpath (@{$file->{"outpaths"}}[0]) {
            if (! -e $outpath && $options{"commit"}) {
                system "mkdir -p '$outpath'";
            }
            if (! -f $outpath."/".$file->{"newfile"}) {
                if ($options{"commit"}) {
                    system sprintf("mv \"%s\" \"%s\"", $file->{"filepath"}, $outpath."/".$file->{"newfile"});
                }
                printf("Old: %s\n", $file->{"filepath"});
                printf("New: %s\n\n", $outpath."/".$file->{"newfile"});
            }
            else {
                if ($file->{"filepath"} ne $outpath."/".$file->{"newfile"}) {
                    print "Duplicate found:\n";
                    printf("Old: \"%s\"\nNew: \"%s\"\n", $file->{"filepath"}, $outpath."/".$file->{"newfile"});
                }
            }
        }
    }
    exit if !$options{"commit"};
    system "find '$ARGV[0]' -empty -delete";
    system "find '$out' -type f -not -perm 600 -exec chmod 600 {} \\;";
    system "find '$out' -type d -not -perm 700 -exec chmod 700 {} \\;";
    system "find '$out' -not -user marwinfaiter -exec chown marwinfaiter:marwinfaiter {} \\; , -not -group marwinfaiter -exec chown marwinfaiter:marwinfaiter {} \\;";
}

sub video_info {
    my @LIST = @_;
    foreach my $file (@LIST) {
        chomp(my @videoinfo = `ffmpeg -i "$file->{filepath}" 2>&1 | egrep "Duration|Video:"`);
        foreach my $row (@videoinfo) {
            if ($row =~ /Duration: (\d{2}:\d{2}:\d{2})\.\d{2}/) {
                $file->{"duration"} = $1;
            }
            if ($row =~ /Video:/) {
                $file->{"resolution"} = (split(",",$row))[2];
            }
        }
    }
    return @LIST;
}

sub find_duplicates {
    my @LIST = @_;
    my $count = {};
    foreach my $file(@LIST) {
        foreach my $attribute(("newfile","duration")) {
            push @{$count->{$attribute}->{$file->{$attribute}}}, $file->{"filepath"} if $file->{$attribute};
        }
    }
    return $count;
}

sub unique {
    my %seen;
    return grep !$seen{$_}++, @_;
}
