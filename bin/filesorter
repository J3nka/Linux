#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use Getopt::Long;
use Term::ANSIColor;

my %options;

Getopt::Long::GetOptions(
    "help"         => sub{help()},

    "commit"       => \$options{"commit"},
    "overwrite"    => \$options{"overwrite"},
    "dir=s"        => \$options{"dir"},
    "noprompt"     => \$options{"noprompt"},
    "list"         => \$options{"list"},

    "duplicates"   => \$options{"duplicates"},

    "addactor=s"   => \@{${options}{add}{actor}},
    "actorlast"    => \$options{add}{actorlast},
    "actorstatic"  => \$options{add}{actorstatic},
    "addsource=s"  => \@{${options}{add}{source}},
    "sourcelast"   => \$options{add}{sourcelast},
    "sourcestatic" => \$options{add}{sourcestatic},
    "addstory=s"   => \@{${options}{add}{story}},
    "storylast"    => \$options{add}{storylast},
    "storystatic"  => \$options{add}{storystatic},

    "actor=s"      => \@{$options{"filter"}{"actor"}},
    "source=s"     => \@{$options{"filter"}{"source"}},
    "story=s"      => \@{$options{"filter"}{"story"}},
    "title=s"      => \@{$options{"filter"}{"title"}},
    "quality=s"    => \@{$options{"filter"}{"quality"}},
    "filetype=s"   => \@{$options{"filter"}{"filetype"}},
    "date=s"       => \@{$options{"filter"}{"date"}},
) or help();

sub help {
print "Usage: $0 <input folder 1> <input folder 2> <...> <options>
--help              Print this helptext

--commit            Move files and clean input directories
--overwrite         Move files even on duplicate
--dir               Set a custom output directory(Default is same as input)
--noprompt          Dont prompt for source names
--list              List files instead of renaming and moving. Works with filters

--duplicates        Search for duplicates(finds files with same new name or same duration)

--addactor          Add actors to files, will still add actors from filename(can be specified multiple times)
--actorlast         Add added actors last instead of first
--actorstatic       Add added actors indead of the the filenames
--addsource         Add static source to files, will still add sources from filename(can be specified multiple times)
--sourcelast        Add added sources last instead of first
--sourcetatic       Add added sources indead of the the filenames
--addstory          Add static story to files, will still add stories from filename(can be specified multiple times)
--storylast         Add added stories last instead of first
--storystatic       Add added stories indead of the the filenames

Filters(can be specified multiple times):
--actor             Filter by actor
--source            Filter by source
--story             Filter by story
--title             Filter by title
--quality           Filter by quality
--filetype          Filter by filetype
--date              Filter by date
";
exit;
}

help() if !@ARGV;
my @LIST;
foreach my $arg (@ARGV) {
    my @filepaths;
    chomp(@filepaths = `find "$arg" -type f`);
    foreach my $path (@filepaths) {
        $path = {
            filepath => $path,
            inpath   => $arg,
            dir      => $options{"dir"} // $arg,
        };
    }
    push @LIST, @filepaths;
}
my %renamedata;
get_actors(@LIST);
build_renamehash($_) for @LIST;
filter(@LIST);

if ($options{"duplicates"}) {
    build_renamehash($_, duplicate => 1) for @LIST;
    my $count = find_duplicates(@LIST);
    foreach my $attribute(keys %$count) {
        foreach my $duplicate ( grep {scalar @{$count->{$attribute}->{$_}} < 2 } keys %{$count->{$attribute}}) {
            delete $count->{$attribute}->{$duplicate};
        }
    }
    print Dumper $count;
    exit;
}

if ($options{"list"}) {
    print $_->{filepath},"\n" for @LIST;
    exit;
}

build_movepath(@LIST);
move_clean(@LIST);

sub filter {
    my @LIST = @_;
    foreach my $param (keys %{$options{"filter"}}) {
        if (scalar @{$options{"filter"}{$param}} > 0) {
            @LIST = grep {
                    if ($_->{$param}) {
                        my $regex = join("|",@{$options{"filter"}{$param}});
                        if (ref $_->{$param} eq "ARRAY") {
                            grep { /$regex/i } @{$_->{$param}};
                        }
                        else {
                            $_->{$param} =~ /$regex/i;
                        }
                    }
                } @LIST;
        }
    }
    return @LIST;
}

sub get_actors {
    my @LIST = @_;
    foreach my $file (@LIST) {
        my $filename = (split("/",$file->{"filepath"}))[-1];
        my @actors = sort ($filename =~ /\(([^()]+)\)/g);
        push @{$renamedata{"actors"}}, @actors;
    }

    @{$renamedata{"actors"}} = grep { scalar (split(" ",$_)) > 1 } @{$renamedata{"actors"}};
    @{$renamedata{"actors"}} = unique(sort @{$renamedata{"actors"}});
    foreach my $actor (@{$renamedata{"actors"}}) {
        my @names = split (" ", $actor);
        $_ = lc $_ and $_ = ucfirst $_ for @names;
        $actor = join(" ", @names);
    }
}

sub build_renamehash {
    my $file = shift;
    my @filesplit = split("/",$file->{"filepath"});
    $file->{"newfile"} = $file->{"orgfile"} = pop @filesplit;
    $file->{"newfile"} =~ s/([\w']+)/\u\L$1/g;
    $file->{"newfile"} =~ s/\s+/ /g;
    $file->{"newfile"} =~ s/^\s+|\s+$//g;

    get_filetype($file);
    get_source($file);
    get_actor($file);
    get_story($file);
    get_quality($file);
    get_date($file);
    add_custom_data($file);
    build_newfile($file);
}

sub get_filetype {
    my $file = shift;
    $file->{"newfile"} =~ s/(\.\w+$)/\L$1/g;
    if ($file->{"newfile"} =~ /\.(\w+)$/) {
        $file->{"filetype"} = $1;
        $file->{"newfile"} =~ s/\.\w+$//;
    }
    else {
        push @{$file->{"error"}}, "No filetype";
    }
}

sub get_source {
    my $file = shift;
    push @{$file->{"source"}}, $file->{"orgfile"} =~ /\[([^\[\]]+)\]/g;
    foreach my $source (@{$file->{"source"}}) {
        my $orgsource = $source;
        if (my @match = grep { $_ =~ /^(?:$source)$/i } keys %{$renamedata{"sources"}}) {
            $source = $renamedata{"sources"}{$match[0]};
        }
        else {
            if (!$options{"noprompt"}) {
                print "Enter source [$source]: ";
                chomp ($source = <STDIN>);
            }
            $source = $orgsource if $source eq "";
            $renamedata{"sources"}{$orgsource} = $source;
        }
    }
    $file->{"newfile"} =~ s/\[[^\[\]]+\]//ig;
}

sub get_actor {
    my $file = shift;
    if ($renamedata{"actors"}) {
        foreach my $actor(@{$renamedata{"actors"}}) {
            if ($file->{"newfile"} =~ /(^| )\(?$actor\)?($| )/i) {
                $file->{"newfile"} =~ s/(^| )\(?$actor\)?($| )/$1($actor)$2/i;
            }
        }
    }
    push @{$file->{"actor"}}, sort ($file->{"newfile"} =~ /\(([^()]+)\)/g);
    $file->{"newfile"} =~ s/\(([^()]+)\)//g;
    my $actors = join("|",@{$file->{"actor"}});
    while ($actors ne "" && $file->{"newfile"} =~ /^\s*($actors)/) {
        $file->{"newfile"} =~ s/^\s*($actors)//;
    }
}

sub get_story {
    my $file = shift;
    push @{$file->{"story"}}, $file->{"newfile"} =~ /\{([^{}]+)\}/g;
    $file->{"newfile"} =~ s/\{([^{}]+)\}//g;
}

sub get_quality {
    my ($file,%args) = @_;
    if ($file->{newfile} && $file->{"newfile"} =~ /(^| )(\d{3,4})p($| )/i) {
        $file->{"quality"} = $2;
    }
    else {
        chomp(my @mediainfo = `ffmpeg -i "$file->{filepath}" 2>&1 | egrep "Duration|Video:"`);
        my @mediainfo2;
        eval {
            no warnings "all";
            @mediainfo2 = grep {/\d{3,4}x\d{3,4}/} split(",",$mediainfo[1]);
            my $resolution = (split("x",$mediainfo2[0]))[1];
            $file->{"quality"} = (split(" ",$resolution))[0] // undef;
        } or push @{$file->{error}}, "Resolution";
        eval {
            no warnings "all";
            @mediainfo2 = grep {/bitrate/} split(",",$mediainfo[0]);
            my ($bitrate) = $mediainfo2[0] =~ /bitrate: (\d+)/;
            $file->{"bitrate"} = $bitrate // undef;
        } or push @{$file->{error}}, "Bitrate";
    }
    $file->{"newfile"} =~ s/(^| )(\d{3,4})p($| )/$1$3/i if $file->{newfile};
}

sub get_date {
    my $file = shift;
    if ($file->{"newfile"} =~ /(^| )(\d{4}\D\d{2}\D\d{2})($| )/) {
        $file->{"date"} = $2;
        $file->{"date"} =~ s/\D/ /g;
        $file->{"newfile"} =~ s/(^| )(\d{4}\D\d{2}\D\d{2})($| )/$1$3/;
    }
}

sub add_custom_data {
    my $file = shift;
    foreach my $attribute (("actor","source","story")) {
        if ($options{add}{"$attribute"."static"}) {
            @{$file->{$attribute}} = @{$options{add}{$attribute}};
        }
        elsif ($options{add}{"$attribute"."last"}) {
            push @{$file->{$attribute}}, @{$options{add}{$attribute}};
        }
        else {
            unshift @{$file->{$attribute}}, @{$options{add}{$attribute}};
        }
    }
}

sub build_newfile {
    my $file = shift;
    $file->{"newfile"} =~ s/^\s+|\s+$//g;
    $file->{"newfile"} =~ s/\s{2,}/ /g;
    $file->{"newfile"} = undef if $file->{newfile} eq "";
    my @filename;
    (scalar @{$file->{"source"}} > 0) and push @filename, join("",map { "[$_]" } @{$file->{"source"}});
    (scalar @{$file->{"actor"}} > 0) and push @filename, join(" ",map { "($_)" } sort @{$file->{"actor"}});
    (scalar @{$file->{"story"}} > 0) and push @filename, join(" ",map { "{$_}" } @{$file->{"story"}});
    push @filename, $file->{"newfile"};
    push @filename, $file->{"date"} // undef;
    push @filename, ($file->{"quality"}."p") // undef;
    $file->{"newfile"} = sprintf("%s.%s", join(" ", grep { defined $_ } @filename), $file->{"filetype"});
}

sub build_movepath {
    my @LIST = @_;
    foreach my $file (@LIST) {
        my @movepaths;
        my @movepath;
        push @movepath, $file->{"dir"};
        push @movepath, scalar @{$file->{"source"}} > 0? @{$file->{"source"}}:"Other";
        if (scalar @{$file->{"actor"}} > 0) {
            push @movepath, ("#Actors",join(" & ", @{$file->{"actor"}}));
        }
        push @movepath, @{$file->{"story"}};
        push @movepaths, join("/",@movepath);
        @{$file->{"outpaths"}} = @movepaths;
    }
}

sub move_clean {
    my @LIST = @_;
    foreach my $file (grep {!$_->{"error"}} @LIST) {
        foreach my $outpath (@{$file->{"outpaths"}}[0]) {
            if (! -e $outpath && $options{"commit"}) {
                system "mkdir -p -m 700 \"$outpath\"";
            }
            if (($options{overwrite} && $file->{"filepath"} ne $outpath."/".$file->{"newfile"}) || ! -f $outpath."/".$file->{"newfile"}) {
                if ($options{"commit"}) {
                    system sprintf("chmod 600 \"%s\"", $file->{filepath});
                    system sprintf("mv \"%s\" \"%s\"", $file->{"filepath"}, $outpath."/".$file->{"newfile"});
                }
                printf("Old: \"%s\"\n", $file->{"filepath"});
                printf("New: \"%s\"\n\n", $outpath."/".$file->{"newfile"});
            }
            else {
                if ($file->{"filepath"} ne $outpath."/".$file->{"newfile"}) {
                    my $oldfile = { filepath => $outpath."/".$file->{"newfile"} };
                    foreach ($oldfile, $file) {
                        if (!$_->{quality} || !$_->{bitrate}) {
                            get_quality($_);
                        }
                    }
                    push @{$file->{"error"}}, sprintf("Duplicate: \"%s\"\nResolution(old/new): %s\nBitrate(old/new): %s\n",
                        $outpath."/".$file->{"newfile"},
                        ($oldfile->{quality}//"")."/".($file->{quality}//""),
                        ($oldfile->{bitrate}//"")."/".($file->{bitrate}//"")
                    );
                }
            }
        }
    }
    foreach my $file (grep {$_->{"error"}} @LIST) {
        printf("\"%s\"\n%s\n", colored($file->{filepath}, "red"), join("\n",@{$file->{"error"}}));
    }
    foreach (@ARGV) {
        system sprintf("find \"%s\" -empty -delete", $_) if $options{commit};
    }
    print $options{commit}? colored("Moved files and cleaned old folders\n","green"):colored("No changes made\n","yellow");
}

sub find_duplicates {
    my @LIST = @_;
    my $count = {};
    foreach my $file(@LIST) {
        foreach my $attribute(("newfile","duration")) {
            push @{$count->{$attribute}->{$file->{$attribute}}}, $file->{"filepath"} if $file->{$attribute};
        }
    }
    return $count;
}

sub unique {
    my %seen;
    return grep !$seen{$_}++, @_;
}
